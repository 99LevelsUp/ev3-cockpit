<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src __CSP_SOURCE__ 'unsafe-inline'; font-src __CSP_SOURCE__; script-src 'nonce-__NONCE__';">
__CODICONS_LINK_TAG__
<style>
	body {
		font-family: var(--vscode-font-family);
		font-size: var(--vscode-font-size);
		color: var(--vscode-foreground);
		background: var(--vscode-sideBar-background, var(--vscode-editor-background));
		padding: 0;
		margin: 0;
		overflow: hidden;
	}
	#root {
		height: 100vh;
		display: flex;
		flex-direction: column;
	}
	.config-error {
		padding: 6px 12px 0;
		color: var(--vscode-errorForeground);
	}
	.brick-detail-shell {
		position: relative;
		flex: 1 1 auto;
		min-height: 0;
	}
	.brick-detail-area {
		background: var(--vscode-editor-background);
		height: 100%;
		min-height: 0;
		overflow-y: auto;
		overflow-x: hidden;
		position: relative;
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	.brick-tabs-wrap {
		position: relative;
	}
	.brick-tabs {
		display: flex;
		align-items: flex-end;
		flex-wrap: nowrap;
		gap: 0;
		padding: 8px 8px 0;
		overflow: visible;
	}
	.brick-tab-baseline {
		position: absolute;
		left: 0;
		right: 0;
		bottom: 0;
		height: 1px;
		background: var(--vscode-panel-border, var(--vscode-editorWidget-border, transparent));
		pointer-events: none;
	}
	.brick-tab-baseline-gap {
		position: absolute;
		bottom: 0;
		height: 2px;
		background: var(--vscode-editor-background);
		pointer-events: none;
		z-index: 3;
		display: none;
	}
	.brick-tabs-main {
		display: block;
		flex: 0 0 auto;
		max-width: 100%;
		position: relative;
		overflow: visible;
	}
	.brick-tabs-scroller {
		display: block;
		flex: 0 0 auto;
		max-width: 100%;
		min-width: 0;
		position: relative;
	}
	.brick-tabs-track {
		display: flex;
		align-items: flex-end;
		min-width: 0;
	}
	.brick-tabs.tabs-overflowing .brick-tabs-scroller {
		flex: 1 1 auto;
		min-width: 0;
	}
	.brick-tabs.tabs-overflowing .brick-tabs-main {
		overflow-x: auto;
		overflow-y: hidden;
		scrollbar-width: none;
		-ms-overflow-style: none;
	}
	.brick-tabs.tabs-overflowing .brick-tabs-track {
		min-width: max-content;
		padding-bottom: 0;
	}
	.brick-tab {
		display: flex;
		align-items: center;
		gap: 4px;
		padding: 6px 10px;
		margin: 0 2px -1px 0;
		border: 1px solid var(--vscode-panel-border, var(--vscode-editorWidget-border, transparent));
		border-top-left-radius: 0;
		border-top-right-radius: 0;
		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;
		border-bottom-color: transparent;
		cursor: pointer;
		background: transparent;
		color: var(--vscode-tab-inactiveForeground, var(--vscode-foreground));
		font-size: var(--vscode-font-size);
		white-space: nowrap;
		flex: 0 0 auto;
		min-width: 44px;
	}
	.brick-tab-label {
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
		flex: 1 1 auto;
		min-width: 0;
		margin-right: 2px;
	}
	.brick-tab-action {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		width: auto;
		height: auto;
		padding: 3px;
		border-radius: 5px;
		color: inherit;
		flex: 0 0 auto;
	}
	.tab-action-icon-svg {
		display: block;
		width: 16px;
		height: 16px;
		fill: currentColor;
		stroke: none;
	}
	.tab-action-icon-codicon {
		display: block;
		font-size: 16px;
		line-height: 16px;
	}
	.brick-tab-close {
		margin-left: -2px;
		margin-right: -2px;
		opacity: 0;
		pointer-events: none;
		cursor: pointer;
		transition: opacity .1s linear;
	}
	.brick-tab:hover .brick-tab-close,
	.brick-tab:focus-visible .brick-tab-close,
	.brick-tab.active .brick-tab-close {
		opacity: 0.85;
		pointer-events: auto;
	}
	.brick-tab-close:hover {
		opacity: 1;
		background: var(--vscode-toolbar-hoverBackground, var(--vscode-list-hoverBackground));
	}
	.brick-tab-config-group {
		position: relative;
		display: inline-flex;
		align-items: center;
		margin-left: 0;
		margin-right: -2px;
		opacity: 0;
		pointer-events: none;
		transition: opacity .1s linear;
	}
	.brick-tab.active .brick-tab-config-group {
		opacity: 0.9;
		pointer-events: auto;
	}
	.brick-tab.active .brick-tab-config-group:hover {
		opacity: 1;
	}
	.brick-tab-config-button {
		cursor: pointer;
	}
	.brick-tab-config-group > .brick-tab-config-button {
		width: 22px;
		height: 22px;
		padding: 3px;
		box-sizing: border-box;
	}
	.brick-tab-config-apply {
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
	}
	.brick-tab-config-group > .brick-tab-config-menu-toggle {
		width: 13px;
		min-width: 13px;
		max-width: 13px;
		padding: 0;
		border-top-left-radius: 0;
		border-bottom-left-radius: 0;
		position: relative;
	}
	.brick-tab-config-group > .brick-tab-config-menu-toggle::before {
		content: '';
		position: absolute;
		left: 0;
		top: 3px;
		bottom: 3px;
		width: 1px;
		background: var(--vscode-toolbar-separator, var(--vscode-panel-border, transparent));
	}
	.brick-tab-config-group > .brick-tab-config-menu-toggle .tab-action-icon-svg {
		width: 10px;
		height: 10px;
	}
	.brick-tab-config-group > .brick-tab-config-menu-toggle .tab-action-icon-codicon {
		font-size: 10px;
		line-height: 10px;
	}
	.brick-tab-config-button:hover {
		background: var(--vscode-toolbar-hoverBackground, var(--vscode-list-hoverBackground));
	}
	.brick-tab-config-button[disabled] {
		opacity: 0.6;
		pointer-events: none;
	}
	.brick-tab-config-apply {
		color: var(--vscode-testing-iconPassed, var(--vscode-charts-green, var(--vscode-terminal-ansiGreen)));
	}
	.brick-tab-config-cancel {
		color: var(--vscode-testing-iconFailed, var(--vscode-errorForeground));
	}
	.brick-tab-config-menu {
		position: absolute;
		top: calc(100% + 4px);
		right: 0;
		display: flex;
		flex-direction: column;
		padding: 4px;
		gap: 2px;
		border: 1px solid var(--vscode-panel-border, var(--vscode-editorWidget-border, transparent));
		background: var(--vscode-editorWidget-background, var(--vscode-editor-background));
		box-shadow: var(--vscode-widget-shadow, none);
		z-index: 30;
	}
	.brick-tab:hover {
		background: var(--vscode-tab-hoverBackground, var(--vscode-list-hoverBackground));
		border-bottom-color: transparent;
	}
	.brick-tab.active {
		background: var(--vscode-tab-activeBackground, var(--vscode-editor-background));
		color: var(--vscode-tab-activeForeground, var(--vscode-foreground));
		border-bottom-color: var(--vscode-tab-activeBackground, var(--vscode-editor-background));
		position: relative;
		z-index: 2;
	}
	.brick-tab.add-tab {
		min-width: 32px;
		justify-content: center;
	}
	.brick-tab-add-icon {
		margin-left: 0;
	}
	.overlay-scrollbar {
		position: absolute;
		opacity: 0;
		pointer-events: none;
		background: var(--vscode-scrollbar-background);
		z-index: 11;
		transition: opacity .1s linear;
	}
	.overlay-scrollbar.visible {
		opacity: 1;
		pointer-events: auto;
		transition: opacity .1s linear;
	}
	.overlay-scrollbar.fade {
		transition: opacity .8s linear;
	}
	.overlay-scrollbar-thumb {
		position: absolute;
		border-radius: 0;
		border: 2px solid transparent;
		background-clip: content-box;
		background: var(--vscode-scrollbarSlider-background);
	}
	.overlay-scrollbar-thumb:hover {
		background: var(--vscode-scrollbarSlider-hoverBackground);
	}
	.overlay-scrollbar-thumb.active {
		background: var(--vscode-scrollbarSlider-activeBackground);
	}
	.overlay-scrollbar-horizontal {
		left: 0;
		right: 0;
		bottom: 0;
		height: 3px;
	}
	.overlay-scrollbar-horizontal .overlay-scrollbar-thumb {
		top: 0;
		height: 3px;
		min-width: 20px;
	}
	.overlay-scrollbar-vertical {
		top: 0;
		right: 0;
		bottom: 0;
		width: 10px;
	}
	.overlay-scrollbar-vertical .overlay-scrollbar-thumb {
		left: 0;
		width: 10px;
		min-height: 20px;
	}
	.brick-detail-area::-webkit-scrollbar,
	.brick-tabs-main::-webkit-scrollbar {
		width: 0;
		height: 0;
	}
	.discovery-section {
		padding: 8px 12px 12px;
	}
	.discovery-title {
		margin: 0 0 14px;
		font-size: 26px;
		line-height: 1.2;
		font-weight: 300;
	}
	.discovery-message {
		opacity: 0.9;
		padding: 4px 0;
	}
	.discovery-list {
		display: flex;
		flex-direction: column;
		gap: 2px;
	}
	.discovery-item {
		display: flex;
		align-items: center;
		width: 100%;
		padding: 6px 4px;
		border: none;
		border-radius: 6px;
		background: transparent;
		color: var(--vscode-foreground);
		cursor: pointer;
		text-align: left;
	}
	.discovery-item:hover:not(:disabled) {
		background: var(--vscode-list-hoverBackground);
	}
	.discovery-item.selected {
		background: var(--vscode-list-activeSelectionBackground, var(--vscode-list-hoverBackground));
		color: var(--vscode-list-activeSelectionForeground, var(--vscode-foreground));
	}
	.discovery-item.status-available {
		border-left: none;
	}
	.discovery-item.status-ready {
		border-left: none;
	}
	.discovery-item.status-connecting {
		border-left: none;
	}
	.discovery-item.status-error {
		border-left: none;
	}
	.discovery-item.status-unavailable {
		border-left: none;
	}
	.discovery-item.status-unknown {
		border-left: none;
	}
	.discovery-item:disabled {
		opacity: 0.6;
		cursor: wait;
	}
	.discovery-main {
		display: inline-flex;
		align-items: center;
		gap: 10px;
		font-size: 13px;
		font-weight: 400;
		line-height: 20px;
		width: 100%;
	}
	.discovery-main-label {
		flex: 1 1 auto;
		min-width: 0;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
	.discovery-item-action {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		margin-left: 8px;
		width: 22px;
		height: 22px;
		padding: 0;
		border: none;
		border-radius: 4px;
		font-size: 14px;
		line-height: 1;
		background: transparent;
		color: var(--vscode-disabledForeground, var(--vscode-descriptionForeground, var(--vscode-foreground)));
		cursor: pointer;
		flex: 0 0 auto;
		transition: color .1s linear;
	}
	.discovery-item-action .codicon {
		font-size: 14px;
		line-height: 14px;
	}
	.discovery-item-action:hover {
		background: transparent;
		color: var(--vscode-foreground);
	}
	.discovery-item-action[aria-disabled="true"] {
		opacity: 0.55;
		pointer-events: none;
	}
	.config-editor {
		padding: 12px;
		display: flex;
		flex-direction: column;
		gap: 8px;
	}
	.config-editor-title {
		font-size: 14px;
		font-weight: 600;
	}
	.config-editor-label {
		font-size: 12px;
		opacity: 0.85;
	}
	.config-editor-input {
		width: 100%;
		box-sizing: border-box;
		padding: 6px 8px;
		border: 1px solid var(--vscode-input-border, var(--vscode-panel-border, transparent));
		background: var(--vscode-input-background, var(--vscode-editor-background));
		color: var(--vscode-input-foreground, var(--vscode-foreground));
		outline: none;
	}
	.config-editor-input:focus {
		border-color: var(--vscode-focusBorder);
	}
	.transport-indicator {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		width: 14px;
		height: 14px;
		flex-shrink: 0;
	}
	.discovery-main .transport-indicator {
		width: 20px;
		height: 20px;
	}
	.transport-indicator.status-available {
		color: var(--vscode-charts-blue, var(--vscode-terminal-ansiBlue));
	}
	.transport-indicator.status-ready {
		color: var(--vscode-testing-iconPassed, var(--vscode-charts-green, var(--vscode-terminal-ansiGreen)));
	}
	.transport-indicator.status-connecting {
		color: var(--vscode-charts-yellow, var(--vscode-terminal-ansiYellow));
	}
	.transport-indicator.status-unavailable {
		color: var(--vscode-disabledForeground);
	}
	.transport-indicator.status-error {
		color: var(--vscode-testing-iconFailed, var(--vscode-errorForeground));
	}
	.transport-indicator.status-unknown {
		color: var(--vscode-charts-blue, var(--vscode-terminal-ansiBlue));
	}
	.transport-icon-svg {
		display: block;
		width: 14px;
		height: 14px;
		fill: none;
		stroke: currentColor;
		stroke-width: 1.6;
		stroke-linecap: round;
		stroke-linejoin: round;
	}
	.transport-icon-symbol-svg {
		display: block;
		width: 14px;
		height: 14px;
		fill: currentColor;
		stroke: none;
	}
	.transport-icon-codicon {
		display: block;
		font-size: 14px;
		line-height: 14px;
	}
	.discovery-main .transport-icon-svg {
		width: 20px;
		height: 20px;
	}
	.discovery-main .transport-icon-symbol-svg {
		width: 20px;
		height: 20px;
	}
	.discovery-main .transport-icon-codicon {
		font-size: 20px;
		line-height: 20px;
	}
	.brick-info {
		padding: 12px;
	}
	.brick-info dt {
		font-weight: bold;
		margin-top: 8px;
	}
	.brick-info dd {
		margin: 2px 0 0 0;
		opacity: 0.85;
	}
	.empty-message {
		padding: 16px;
		opacity: 0.7;
		text-align: center;
	}
	.error-text {
		color: var(--vscode-errorForeground);
	}
	.sensor-section {
		padding: 8px 12px;
		border-top: 1px solid var(--vscode-panel-border, var(--vscode-editorWidget-border, transparent));
	}
	.sensor-section h3 {
		margin: 4px 0 8px;
		font-size: var(--vscode-font-size);
		font-weight: bold;
	}
	.sensor-port {
		display: flex;
		justify-content: space-between;
		padding: 3px 0;
		opacity: 0.85;
	}
	.sensor-port.disconnected {
		opacity: 0.45;
	}
	.sensor-port-label {
		font-weight: bold;
		min-width: 50px;
	}
	.motor-section {
		padding: 8px 12px;
		border-top: 1px solid var(--vscode-panel-border, var(--vscode-editorWidget-border, transparent));
	}
	.motor-section h3 {
		margin: 4px 0 8px;
		font-size: var(--vscode-font-size);
		font-weight: bold;
	}
	.motor-port {
		display: flex;
		justify-content: space-between;
		padding: 3px 0;
		opacity: 0.85;
	}
	.motor-port.stopped {
		opacity: 0.45;
	}
	.motor-port-label {
		font-weight: bold;
		min-width: 50px;
	}
	.controls-section {
		padding: 8px 12px;
		border-top: 1px solid var(--vscode-panel-border, var(--vscode-editorWidget-border, transparent));
	}
	.controls-section h3 {
		margin: 4px 0 8px;
		font-size: var(--vscode-font-size);
		font-weight: bold;
	}
	.controls-row {
		display: flex;
		justify-content: space-between;
		padding: 3px 0;
		opacity: 0.85;
	}
	.controls-label {
		font-weight: bold;
		min-width: 80px;
	}
</style>
</head>
<body>
	<div id="root"></div>
	<script nonce="__NONCE__">
		const vscode = acquireVsCodeApi();

		let bricks = [];
		let sensors = [];
		let motors = [];
		let controls = null;
		let discoveryOpen = false;
		let discoveryLoading = false;
		let discoveryError = '';
		let discoveryCandidates = [];
		let selectedDiscoveryCandidateId = '';
		let connectingDiscoveryCandidateId = '';
		const configStateByBrickId = new Map();
		const discardRequestKindByBrickId = new Map();
		let keepDiscoveryOpenOnConnectCandidateId = '';
		let detailScrollTop = 0;
		let tabsScrollLeft = 0;
		let suppressRenderUntil = 0;
		let resizeListenerAttached = false;
		let initialAutoScanPending = true;
		let scanInFlight = false;
		let scanLoopTimer = null;
		let scanLoopMode = '';
		let lastScanBackground = false;
		let nextBrickOrder = 0;
		const brickOrderById = new Map();
		const DISCOVERY_REFRESH_FAST_MS = __DISCOVERY_REFRESH_FAST_MS__;
		const DISCOVERY_REFRESH_SLOW_MS = __DISCOVERY_REFRESH_SLOW_MS__;
		const TRANSPORT_ICONS = __TRANSPORT_ICONS_LITERAL__;
		const TAB_ACTION_ICONS = __TAB_ACTION_ICONS_LITERAL__;

		function isPlusTabActive() {
			return discoveryOpen || bricks.length === 0;
		}

		function stopScanLoop() {
			if (scanLoopTimer) {
				clearTimeout(scanLoopTimer);
				scanLoopTimer = null;
			}
			scanLoopMode = '';
		}

		function scheduleNextScan(force = false) {
			const desiredMode = isPlusTabActive() ? 'fast' : 'slow';
			const delay = desiredMode === 'fast' ? DISCOVERY_REFRESH_FAST_MS : DISCOVERY_REFRESH_SLOW_MS;
			if (scanInFlight) {
				scanLoopMode = desiredMode;
				return;
			}
			if (!force && scanLoopTimer && scanLoopMode === desiredMode) {
				return;
			}
			stopScanLoop();
			scanLoopMode = desiredMode;
			scanLoopTimer = setTimeout(() => {
				scanLoopTimer = null;
				requestDiscoveryScan({
					preserveCandidates: true,
					openUi: isPlusTabActive(),
					background: !isPlusTabActive()
				});
			}, delay);
		}

		function mergeDiscoveryCandidates(nextCandidates) {
			const previousCandidates = discoveryCandidates;
			const byId = new Map();
			for (const candidate of nextCandidates || []) {
				if (!candidate || !candidate.candidateId) {
					continue;
				}
				if (isHiddenDiscoveryCandidate(candidate)) {
					continue;
				}
				byId.set(candidate.candidateId, candidate);
			}
			discoveryCandidates = Array.from(byId.values());
			let changed = !isSameSnapshot(discoveryCandidates, previousCandidates);
			if (selectedDiscoveryCandidateId && !byId.has(selectedDiscoveryCandidateId)) {
				selectedDiscoveryCandidateId = '';
				changed = true;
			}
			return changed;
		}

		function isHiddenDiscoveryCandidate(candidate) {
			if (!candidate) {
				return true;
			}
			const candidateId = typeof candidate.candidateId === 'string'
				? candidate.candidateId.trim().toLowerCase()
				: '';
			const displayName = typeof candidate.displayName === 'string'
				? candidate.displayName.trim().toLowerCase()
				: '';
			const detail = typeof candidate.detail === 'string'
				? candidate.detail.trim().toLowerCase()
				: '';
			return candidateId === 'active';
		}

		function setCandidateConnectionState(candidateId, status, alreadyConnected) {
			for (const candidate of discoveryCandidates) {
				if (candidate.candidateId !== candidateId) {
					continue;
				}
				candidate.status = status;
				candidate.alreadyConnected = alreadyConnected;
				break;
			}
		}

		function ensureBrickVisibleFromCandidate(candidateId, status) {
			const candidate = discoveryCandidates.find((item) => item.candidateId === candidateId);
			const transport = candidate?.transport || 'unknown';
			const displayName = candidate?.displayName || candidateId;
			let found = false;
			bricks = bricks.map((brick) => {
				if (brick.brickId !== candidateId) {
					return {
						...brick,
						isActive: false
					};
				}
				found = true;
				return {
					...brick,
					displayName,
					transport,
					status,
					isActive: true
				};
			});
			if (!found) {
				bricks.push({
					brickId: candidateId,
					displayName,
					status,
					transport,
					role: 'standalone',
					isActive: true
				});
				bricks = bricks.map((brick) => ({
					...brick,
					isActive: brick.brickId === candidateId
				}));
			}
			bricks = stabilizeBrickOrder(bricks);
		}

		function removeBrickImmediately(brickId) {
			const wasActive = bricks.some((brick) => brick.brickId === brickId && brick.isActive);
			bricks = bricks.filter((brick) => brick.brickId !== brickId);
			configStateByBrickId.delete(brickId);
			discardRequestKindByBrickId.delete(brickId);
			if (wasActive && bricks.length > 0) {
				bricks = bricks.map((brick, index) => ({
					...brick,
					isActive: index === 0
				}));
			}
			bricks = stabilizeBrickOrder(bricks);
			pruneConfigStates();
		}

		function syncDiscoveryCandidatesWithBricks() {
			if (!Array.isArray(discoveryCandidates) || discoveryCandidates.length === 0) {
				return false;
			}
			let changed = false;
			const statusByBrickId = new Map();
			for (const brick of bricks) {
				if (!brick || !brick.brickId) {
					continue;
				}
				statusByBrickId.set(brick.brickId, String(brick.status || '').toUpperCase());
			}
			for (const candidate of discoveryCandidates) {
				if (!candidate || !candidate.candidateId) {
					continue;
				}
				const liveStatus = statusByBrickId.get(candidate.candidateId);
				if (liveStatus === 'AVAILABLE' || liveStatus === 'READY' || liveStatus === 'CONNECTING' || liveStatus === 'UNAVAILABLE' || liveStatus === 'ERROR') {
					const nextAlreadyConnected = liveStatus === 'READY' || liveStatus === 'CONNECTING';
					if (candidate.status !== liveStatus || candidate.alreadyConnected !== nextAlreadyConnected) {
						candidate.status = liveStatus;
						candidate.alreadyConnected = nextAlreadyConnected;
						changed = true;
					}
					continue;
				}
				if (
					candidate.alreadyConnected === true
					&& candidate.candidateId !== connectingDiscoveryCandidateId
				) {
					if (candidate.status !== 'UNAVAILABLE' || candidate.alreadyConnected !== false) {
						candidate.status = 'UNAVAILABLE';
						candidate.alreadyConnected = false;
						changed = true;
					}
				}
			}
			return changed;
		}

		function stabilizeBrickOrder(nextBricks) {
			const normalized = Array.isArray(nextBricks)
				? nextBricks.filter((brick) => brick && brick.brickId)
				: [];
			for (const brick of normalized) {
				if (!brickOrderById.has(brick.brickId)) {
					brickOrderById.set(brick.brickId, nextBrickOrder);
					nextBrickOrder += 1;
				}
			}
			const visibleIds = new Set(normalized.map((brick) => brick.brickId));
			for (const knownId of Array.from(brickOrderById.keys())) {
				if (!visibleIds.has(knownId)) {
					brickOrderById.delete(knownId);
				}
			}
			return normalized.slice().sort((left, right) => {
				const leftOrder = brickOrderById.get(left.brickId) ?? 0;
				const rightOrder = brickOrderById.get(right.brickId) ?? 0;
				return leftOrder - rightOrder;
			});
		}

		function requestDiscoveryScan(options = {}) {
			const openUi = options.openUi !== false;
			const background = options.background === true;
			if (openUi) {
				discoveryOpen = true;
			}
			discoveryLoading = openUi && discoveryCandidates.length === 0;
			discoveryError = '';
			if (!options.preserveCandidates) {
				discoveryCandidates = [];
				selectedDiscoveryCandidateId = '';
				connectingDiscoveryCandidateId = '';
				keepDiscoveryOpenOnConnectCandidateId = '';
			}
			lastScanBackground = background;
			if (scanInFlight) {
				render();
				return;
			}
			scanInFlight = true;
			render();
			vscode.postMessage({ type: 'scanBricks' });
		}

		function renderCodiconReference(iconReference, iconClassName) {
			if (typeof iconReference !== 'string') {
				return '';
			}
			if (!iconReference.startsWith('codicon:')) {
				return iconReference;
			}
			const iconName = iconReference.slice('codicon:'.length).trim();
			if (!iconName) {
				return '';
			}
			return '<span class="codicon codicon-' + iconName + ' ' + iconClassName + '" aria-hidden="true"></span>';
		}

		function renderTransportIcon(transport) {
			const normalized = typeof transport === 'string' ? transport.toLowerCase() : 'unknown';
			const icon = TRANSPORT_ICONS[normalized] || TRANSPORT_ICONS.unknown;
			return renderCodiconReference(icon, 'transport-icon-codicon');
		}

		function renderTabCloseIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.close, 'tab-action-icon-codicon') || '';
		}

		function renderTabAddIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.add, 'tab-action-icon-codicon') || '';
		}

		function renderTabSettingsIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.settings, 'tab-action-icon-codicon') || '';
		}

		function renderTabApplyIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.apply, 'tab-action-icon-codicon') || '';
		}

		function renderTabMenuIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.menu, 'tab-action-icon-codicon') || '';
		}

		function renderTabReloadIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.reload, 'tab-action-icon-codicon') || '';
		}

		function renderTabCancelIcon() {
			return renderCodiconReference(TAB_ACTION_ICONS.cancel, 'tab-action-icon-codicon')
				|| renderCodiconReference(TAB_ACTION_ICONS.close, 'tab-action-icon-codicon')
				|| '';
		}

		function getTabConfigState(brickId) {
			if (!brickId) {
				return {
					mode: false,
					menuOpen: false,
					actionInFlight: '',
					error: '',
					draftBrickName: ''
				};
			}
			const existing = configStateByBrickId.get(brickId);
			if (existing) {
				return existing;
			}
			const created = {
				mode: false,
				menuOpen: false,
				actionInFlight: '',
				error: '',
				draftBrickName: ''
			};
			configStateByBrickId.set(brickId, created);
			return created;
		}

		function getCurrentBrickDisplayName(brickId) {
			const brick = bricks.find((item) => item.brickId === brickId);
			return brick?.displayName || '';
		}

		function pruneConfigStates() {
			const visibleIds = new Set(bricks.map((brick) => brick.brickId));
			for (const brickId of Array.from(configStateByBrickId.keys())) {
				if (!visibleIds.has(brickId)) {
					configStateByBrickId.delete(brickId);
					discardRequestKindByBrickId.delete(brickId);
				}
			}
		}

		function closeAllConfigMenus(exceptBrickId = '') {
			let changed = false;
			for (const [brickId, state] of configStateByBrickId.entries()) {
				if (brickId === exceptBrickId) {
					continue;
				}
				if (state.menuOpen) {
					state.menuOpen = false;
					changed = true;
				}
			}
			return changed;
		}

		function getActiveBrickConfigError() {
			const activeBrick = bricks.find((brick) => brick.isActive);
			if (!activeBrick) {
				return '';
			}
			return getTabConfigState(activeBrick.brickId).error || '';
		}

		function renderTransportIndicator(brick) {
			const status = String(brick.status || '').toLowerCase();
			const statusClass = status === 'available' || status === 'ready' || status === 'connecting' || status === 'unavailable' || status === 'error'
				? 'status-' + status
				: 'status-unknown';
			return '<span class="transport-indicator ' + statusClass + '">' + renderTransportIcon(brick.transport) + '</span>';
		}

		function renderDiscoveryTransportIndicator(candidate) {
			const normalizedStatus = String(candidate.status || '').toLowerCase();
			const connectedStatus = candidate.alreadyConnected ? 'ready' : 'unknown';
			const statusClass = (candidate.candidateId === connectingDiscoveryCandidateId)
				? 'status-connecting'
				: (
					normalizedStatus === 'available'
					|| normalizedStatus === 'ready'
					|| normalizedStatus === 'connecting'
					|| normalizedStatus === 'unavailable'
					|| normalizedStatus === 'error'
				)
					? 'status-' + normalizedStatus
					: 'status-' + connectedStatus;
			return '<span class="transport-indicator ' + statusClass + '">' + renderTransportIcon(candidate.transport) + '</span>';
		}

		function shouldShowTabClose(brick) {
			return !!brick && !!brick.brickId;
		}

		function resolveCandidateStatusClass(candidate) {
			if (candidate.candidateId === connectingDiscoveryCandidateId) {
				return ' status-connecting';
			}
			const normalizedStatus = String(candidate.status || '').toLowerCase();
			if (
				normalizedStatus === 'available'
				|| normalizedStatus === 'ready'
				|| normalizedStatus === 'connecting'
				|| normalizedStatus === 'unavailable'
				|| normalizedStatus === 'error'
			) {
				return ' status-' + normalizedStatus;
			}
			return candidate.alreadyConnected ? ' status-ready' : ' status-unknown';
		}

		function isCandidateReadyConnected(candidate) {
			if (!candidate) {
				return false;
			}
			const status = String(candidate.status || '').toLowerCase();
			return status === 'ready' || (candidate.alreadyConnected === true && status !== 'error' && status !== 'unavailable');
		}

		function isMockDiscoveryCandidate(candidate) {
			if (!candidate) {
				return false;
			}
			if (String(candidate.transport || '').toLowerCase() === 'mock') {
				return true;
			}
			return String(candidate.candidateId || '').toLowerCase().startsWith('mock-');
		}

		function resolveBrickStatus(candidateId) {
			const brick = bricks.find((item) => item && item.brickId === candidateId);
			return String(brick?.status || '').toUpperCase();
		}

		function resolveMockDiscoveryToggle(candidate) {
			if (!isMockDiscoveryCandidate(candidate)) {
				return null;
			}
			const brickStatus = resolveBrickStatus(candidate.candidateId);
			if (brickStatus === 'READY') {
				return {
					mode: 'disconnect',
					iconName: 'debug-connected',
					tooltip: 'Disconnect'
				};
			}
			if (brickStatus === 'UNAVAILABLE') {
				return {
					mode: 'connect',
					iconName: 'debug-disconnect',
					tooltip: 'Reconnect'
				};
			}
			return null;
		}

		function escapeHtml(value) {
			return String(value || '')
				.replaceAll('&', '&amp;')
				.replaceAll('<', '&lt;')
				.replaceAll('>', '&gt;')
				.replaceAll('"', '&quot;')
				.replaceAll("'", '&#39;');
		}

		function isSameSnapshot(left, right) {
			return JSON.stringify(left) === JSON.stringify(right);
		}

		function renderTabConfigControls(brick, isActive) {
			if (!brick || !brick.brickId) {
				return '';
			}
			const state = getTabConfigState(brick.brickId);
			if (!isActive) {
				return '';
			}
			const disabledAttr = state.actionInFlight ? ' disabled' : '';
			let html = '<span class="brick-tab-config-group">';
			if (!state.mode) {
				html += '<span class="brick-tab-action brick-tab-config-button" data-config-enter-brick-id="' + brick.brickId + '" title="Enter configuration mode" aria-label="Enter configuration mode" role="button">'
					+ renderTabSettingsIcon()
					+ '</span>';
				html += '</span>';
				return html;
			}
			html += '<span class="brick-tab-action brick-tab-config-button brick-tab-config-apply" data-config-apply-brick-id="' + brick.brickId + '" title="Apply configuration changes" aria-label="Apply configuration changes" role="button"' + disabledAttr + '>'
				+ renderTabApplyIcon()
				+ '</span>';
			html += '<span class="brick-tab-action brick-tab-config-button brick-tab-config-menu-toggle" data-config-menu-toggle-brick-id="' + brick.brickId + '" title="Configuration actions" aria-label="Configuration actions" role="button"' + disabledAttr + '>'
				+ renderTabMenuIcon()
				+ '</span>';
			if (state.menuOpen) {
				html += '<span class="brick-tab-config-menu">'
					+ '<span class="brick-tab-action brick-tab-config-button" data-config-reload-brick-id="' + brick.brickId + '" title="Reload configuration" aria-label="Reload configuration" role="button"' + disabledAttr + '>'
					+ renderTabReloadIcon()
					+ '</span>'
					+ '<span class="brick-tab-action brick-tab-config-button brick-tab-config-cancel" data-config-cancel-brick-id="' + brick.brickId + '" title="Cancel configuration changes" aria-label="Cancel configuration changes" role="button"' + disabledAttr + '>'
					+ renderTabCancelIcon()
					+ '</span>'
					+ '</span>';
			}
			html += '</span>';
			return html;
		}

		function setupOverlayScrollbar(container, track, thumb, orientation) {
			if (!container || !track || !thumb) {
				return () => {};
			}
			const isHorizontal = orientation === 'horizontal';
			let hideTimer = null;
			let draggingPointerId = null;
			let dragStartPointer = 0;
			let dragStartScroll = 0;

			function clearHideTimer() {
				if (hideTimer) {
					clearTimeout(hideTimer);
					hideTimer = null;
				}
			}

			function hasHover() {
				return container.matches(':hover') || track.matches(':hover');
			}

			function show() {
				clearHideTimer();
				track.classList.remove('fade');
				track.classList.add('visible');
			}

			function hideSlow() {
				if (draggingPointerId !== null || hasHover()) {
					return;
				}
				track.classList.add('fade');
				track.classList.remove('visible');
			}

			function scheduleHide(delay = 220) {
				clearHideTimer();
				hideTimer = setTimeout(() => {
					hideSlow();
				}, delay);
			}

			function getMetrics() {
				const viewportSize = isHorizontal ? container.clientWidth : container.clientHeight;
				const contentSize = isHorizontal ? container.scrollWidth : container.scrollHeight;
				const maxScroll = Math.max(0, contentSize - viewportSize);
				const trackSize = isHorizontal ? track.clientWidth : track.clientHeight;
				if (viewportSize <= 0 || contentSize <= 0 || trackSize <= 0) {
					return null;
				}
				const thumbSize = Math.max(20, Math.round((viewportSize / contentSize) * trackSize));
				const maxThumbOffset = Math.max(1, trackSize - thumbSize);
				const currentScroll = isHorizontal ? container.scrollLeft : container.scrollTop;
				const thumbOffset = maxScroll > 0
					? Math.round((currentScroll / maxScroll) * maxThumbOffset)
					: 0;
				return { maxScroll, trackSize, thumbSize, maxThumbOffset, thumbOffset };
			}

			function updateThumb() {
				const metrics = getMetrics();
				if (!metrics || metrics.maxScroll <= 0) {
					track.style.display = 'none';
					track.classList.remove('visible', 'fade');
					clearHideTimer();
					return;
				}
				track.style.display = 'block';
				if (isHorizontal) {
					thumb.style.width = metrics.thumbSize + 'px';
					thumb.style.left = metrics.thumbOffset + 'px';
					thumb.style.transform = 'none';
				} else {
					thumb.style.height = metrics.thumbSize + 'px';
					thumb.style.top = metrics.thumbOffset + 'px';
					thumb.style.transform = 'none';
				}
			}

			function setScroll(value) {
				if (isHorizontal) {
					container.scrollLeft = value;
				} else {
					container.scrollTop = value;
				}
			}

			function pointerAxisValue(event) {
				return isHorizontal ? event.clientX : event.clientY;
			}

			function trackAxisValue(event) {
				const rect = track.getBoundingClientRect();
				return isHorizontal ? event.clientX - rect.left : event.clientY - rect.top;
			}

			function onPointerMove(event) {
				if (draggingPointerId !== event.pointerId) {
					return;
				}
				event.preventDefault();
				const metrics = getMetrics();
				if (!metrics) {
					return;
				}
				const delta = pointerAxisValue(event) - dragStartPointer;
				const ratio = metrics.maxScroll / metrics.maxThumbOffset;
				const maxScroll = metrics.maxScroll;
				const nextScroll = Math.max(0, Math.min(maxScroll, dragStartScroll + (delta * ratio)));
				setScroll(nextScroll);
				updateThumb();
				show();
			}

			function removeDragListeners() {
				window.removeEventListener('pointermove', onPointerMove, true);
				window.removeEventListener('pointerup', endDrag, true);
				window.removeEventListener('pointercancel', endDrag, true);
			}

			function endDrag(event) {
				if (draggingPointerId !== event.pointerId) {
					return;
				}
				draggingPointerId = null;
				thumb.classList.remove('active');
				if (thumb.releasePointerCapture) {
					try {
						thumb.releasePointerCapture(event.pointerId);
					} catch {
						// no-op: pointer capture can already be released
					}
				}
				removeDragListeners();
				if (!hasHover()) {
					scheduleHide(260);
				}
			}

			thumb.addEventListener('pointerdown', (event) => {
				const metrics = getMetrics();
				if (!metrics || metrics.maxScroll <= 0) {
					return;
				}
				event.preventDefault();
				event.stopPropagation();
				draggingPointerId = event.pointerId;
				dragStartPointer = pointerAxisValue(event);
				dragStartScroll = isHorizontal ? container.scrollLeft : container.scrollTop;
				thumb.classList.add('active');
				show();
				window.addEventListener('pointermove', onPointerMove, true);
				window.addEventListener('pointerup', endDrag, true);
				window.addEventListener('pointercancel', endDrag, true);
				if (thumb.setPointerCapture) {
					try {
						thumb.setPointerCapture(event.pointerId);
					} catch {
						// no-op: pointer capture not available
					}
				}
			});
			thumb.addEventListener('lostpointercapture', (event) => {
				if (draggingPointerId !== event.pointerId) {
					return;
				}
				draggingPointerId = null;
				thumb.classList.remove('active');
				removeDragListeners();
				if (!hasHover()) {
					scheduleHide(260);
				}
			});

			track.addEventListener('pointerdown', (event) => {
				if (event.target === thumb) {
					return;
				}
				const metrics = getMetrics();
				if (!metrics || metrics.maxScroll <= 0) {
					return;
				}
				event.preventDefault();
				const clickOffset = trackAxisValue(event);
				const targetThumbOffset = Math.max(0, Math.min(metrics.maxThumbOffset, clickOffset - (metrics.thumbSize / 2)));
				const targetScroll = metrics.maxThumbOffset > 0
					? (targetThumbOffset / metrics.maxThumbOffset) * metrics.maxScroll
					: 0;
				setScroll(targetScroll);
				updateThumb();
				show();
				if (!hasHover()) {
					scheduleHide(220);
				}
			});

			const onHoverEnter = () => {
				updateThumb();
				show();
			};
			const onHoverLeave = () => {
				if (draggingPointerId === null) {
					scheduleHide(260);
				}
			};

			container.addEventListener('mouseenter', onHoverEnter);
			container.addEventListener('mouseleave', onHoverLeave);
			track.addEventListener('mouseenter', onHoverEnter);
			track.addEventListener('mouseleave', onHoverLeave);
			container.addEventListener('scroll', () => {
				updateThumb();
				show();
				if (draggingPointerId === null && !hasHover()) {
					scheduleHide(220);
				}
			}, { passive: true });

			requestAnimationFrame(() => {
				updateThumb();
				if (!hasHover()) {
					scheduleHide(300);
				}
			});
			return updateThumb;
		}

		function render() {
			const root = document.getElementById('root');
			const previousDetailArea = root.querySelector('.brick-detail-area');
			if (previousDetailArea) {
				detailScrollTop = previousDetailArea.scrollTop;
			}
			const previousTabsMain = root.querySelector('.brick-tabs-main');
			if (previousTabsMain) {
				tabsScrollLeft = previousTabsMain.scrollLeft;
			}
			const activeBrick = bricks.find(b => b.isActive);
			let html = '<div class="brick-tabs-wrap"><div class="brick-tabs"><div class="brick-tabs-scroller"><div class="brick-tabs-main"><div class="brick-tabs-track">';
			for (const brick of bricks) {
				const isActiveTab = !discoveryOpen && brick.isActive;
				const activeClass = isActiveTab ? ' active' : '';
				const closeMarkup = shouldShowTabClose(brick)
					? '<span class="brick-tab-action brick-tab-close" data-close-brick-id="' + brick.brickId + '" title="Disconnect EV3 Brick" aria-label="Disconnect EV3 Brick" role="button">' + renderTabCloseIcon() + '</span>'
					: '';
				html += '<button class="brick-tab' + activeClass + '" data-brick-id="' + brick.brickId + '" title="' + escapeHtml(brick.displayName) + '">'
					+ renderTransportIndicator(brick)
					+ '<span class="brick-tab-label">' + escapeHtml(brick.displayName) + '</span>'
					+ renderTabConfigControls(brick, isActiveTab)
					+ closeMarkup
					+ '</button>';
			}
			html += '</div></div>'
				+ '<div class="overlay-scrollbar overlay-scrollbar-horizontal" data-overlay-track="tabs">'
				+ '<div class="overlay-scrollbar-thumb" data-overlay-thumb="tabs"></div>'
				+ '</div>'
				+ '</div>';
			const addTabActiveClass = (discoveryOpen || bricks.length === 0) ? ' active' : '';
			html += '<button class="brick-tab add-tab' + addTabActiveClass + '" data-add-brick="true" title="Connect EV3 Brick" aria-label="Connect EV3 Brick">'
				+ '<span class="brick-tab-action brick-tab-add-icon" aria-hidden="true">' + renderTabAddIcon() + '</span>'
				+ '</button>';
			html += '</div>';
			html += '<div class="brick-tab-baseline"></div>';
			html += '<div class="brick-tab-baseline-gap"></div>';
			html += '</div>';

			html += '<div class="brick-detail-shell"><div class="brick-detail-area">';
			const activeConfigError = getActiveBrickConfigError();
			if (activeConfigError) {
				html += '<div class="config-error">' + activeConfigError + '</div>';
			}

			if (discoveryOpen) {
				html += '<div class="discovery-section">'
					+ '<div class="discovery-title">Available bricks</div>';
				if (discoveryLoading) {
					html += '<div class="discovery-message">Scanning...</div>';
				} else if (discoveryError) {
					html += '<div class="discovery-message error-text">' + discoveryError + '</div>';
				} else if (!discoveryCandidates || discoveryCandidates.length === 0) {
					html += '<div class="discovery-message">No available Bricks found.</div>';
				} else {
					html += '<div class="discovery-list">';
					for (const candidate of discoveryCandidates) {
						const selectedClass = candidate.candidateId === selectedDiscoveryCandidateId ? ' selected' : '';
						const statusClass = resolveCandidateStatusClass(candidate);
						const disabledAttr = connectingDiscoveryCandidateId ? ' disabled' : '';
						const mockToggle = resolveMockDiscoveryToggle(candidate);
						const mockActionDisabled = connectingDiscoveryCandidateId ? 'true' : 'false';
						html += '<button class="discovery-item' + selectedClass + statusClass + '" data-candidate-id="' + candidate.candidateId + '"' + disabledAttr + '>'
							+ '<span class="discovery-main">'
							+ renderDiscoveryTransportIndicator(candidate)
							+ '<span class="discovery-main-label">' + escapeHtml(candidate.displayName) + '</span>'
							+ (mockToggle
								? '<span class="discovery-item-action" data-candidate-action-id="' + candidate.candidateId + '" data-candidate-action-mode="' + mockToggle.mode + '" aria-disabled="' + mockActionDisabled + '" title="' + mockToggle.tooltip + '" aria-label="' + mockToggle.tooltip + '" role="button">' + renderCodiconReference('codicon:' + mockToggle.iconName, '') + '</span>'
								: '')
							+ '</span>'
							+ '</button>';
					}
					html += '</div>';
				}
				html += '</div>';
			}

			if (!discoveryOpen && activeBrick) {
				const activeState = getTabConfigState(activeBrick.brickId);
				if (activeState.mode) {
					const currentName = getCurrentBrickDisplayName(activeBrick.brickId);
					const draftName = (typeof activeState.draftBrickName === 'string' && activeState.draftBrickName.length > 0)
						? activeState.draftBrickName
						: currentName;
					html += '<div class="config-editor">'
						+ '<div class="config-editor-title">Brick configuration</div>'
						+ '<label class="config-editor-label" for="brick-name-input-' + activeBrick.brickId + '">Brick name</label>'
						+ '<input id="brick-name-input-' + activeBrick.brickId + '" class="config-editor-input" data-config-name-input-brick-id="' + activeBrick.brickId + '" type="text" maxlength="12" value="' + escapeHtml(draftName) + '" />'
						+ '</div>';
				} else {
					html += '<div class="brick-info"><dl>'
						+ '<dt>Status</dt><dd>' + escapeHtml(activeBrick.status) + '</dd>'
						+ '<dt>Transport</dt><dd>' + escapeHtml(activeBrick.transport) + '</dd>'
						+ '<dt>Role</dt><dd>' + escapeHtml(activeBrick.role) + '</dd>';
					if (activeBrick.lastOperation) {
						html += '<dt>Last Operation</dt><dd>' + escapeHtml(activeBrick.lastOperation) + '</dd>';
					}
					if (activeBrick.lastError) {
						html += '<dt>Last Error</dt><dd class="error-text">' + escapeHtml(activeBrick.lastError) + '</dd>';
					}
					html += '</dl></div>';
				}
			}

			const isActiveConfigMode = !discoveryOpen && !!activeBrick && getTabConfigState(activeBrick.brickId).mode;

			if (!isActiveConfigMode && sensors && sensors.length > 0) {
				html += '<div class="sensor-section"><h3>Sensors</h3>';
				for (const s of sensors) {
					const cls = s.connected ? 'sensor-port' : 'sensor-port disconnected';
					const label = (typeof s.layer === 'number' && s.layer > 0)
						? ('L' + s.layer + ' Port ' + (s.port + 1))
						: ('Port ' + (s.port + 1));
					html += '<div class="' + cls + '">'
						+ '<span class="sensor-port-label">' + label + '</span>'
						+ '<span>' + s.typeName + (s.connected ? ' (mode ' + s.mode + ')' : '') + '</span>'
						+ '</div>';
				}
				html += '</div>';
			}

			if (!isActiveConfigMode && motors && motors.length > 0) {
				html += '<div class="motor-section"><h3>Motors</h3>';
				for (const m of motors) {
					const cls = m.running ? 'motor-port' : 'motor-port stopped';
					const label = (typeof m.layer === 'number' && m.layer > 0)
						? ('L' + m.layer + ' Port ' + m.port)
						: ('Port ' + m.port);
					html += '<div class="' + cls + '">'
						+ '<span class="motor-port-label">' + label + '</span>'
						+ '<span>' + (m.running ? 'Speed ' + m.speed + '%' : 'Stopped') + '</span>'
						+ '</div>';
				}
				html += '</div>';
			}

			if (!isActiveConfigMode && controls) {
				html += '<div class="controls-section"><h3>Controls</h3>';
				if (controls.buttonName) {
					html += '<div class="controls-row">'
						+ '<span class="controls-label">Button</span>'
						+ '<span>' + controls.buttonName + '</span>'
						+ '</div>';
				}
				if (typeof controls.ledPattern === 'number') {
					const ledNames = ['Off','Green','Red','Orange','Green Flash','Red Flash','Orange Flash','Green Pulse','Red Pulse','Orange Pulse'];
					html += '<div class="controls-row">'
						+ '<span class="controls-label">LED</span>'
						+ '<span>' + (ledNames[controls.ledPattern] || 'Pattern ' + controls.ledPattern) + '</span>'
						+ '</div>';
				}
				html += '</div>';
			}
			html += '</div>'
				+ '<div class="overlay-scrollbar overlay-scrollbar-vertical" data-overlay-track="detail">'
				+ '<div class="overlay-scrollbar-thumb" data-overlay-thumb="detail"></div>'
				+ '</div>'
				+ '</div>';

			root.innerHTML = html;
			const detailArea = root.querySelector('.brick-detail-area');
			if (detailArea) {
				detailArea.scrollTop = detailScrollTop;
				detailArea.addEventListener('scroll', () => {
					detailScrollTop = detailArea.scrollTop;
					suppressRenderUntil = Date.now() + 250;
				}, { passive: true });
			}
			const tabsRow = root.querySelector('.brick-tabs');
			const tabsMain = root.querySelector('.brick-tabs-main');
			const tabsTrack = root.querySelector('.brick-tabs-track');
			const tabsOverlayTrack = root.querySelector('[data-overlay-track="tabs"]');
			const tabsOverlayThumb = root.querySelector('[data-overlay-thumb="tabs"]');
			const detailOverlayTrack = root.querySelector('[data-overlay-track="detail"]');
			const detailOverlayThumb = root.querySelector('[data-overlay-thumb="detail"]');
			const baselineGap = root.querySelector('.brick-tab-baseline-gap');
			const activeTab = root.querySelector('.brick-tab.active');
			const tabsWrap = root.querySelector('.brick-tabs-wrap');
			function updateTabBaselineGap() {
				if (!baselineGap || !activeTab || !tabsWrap) {
					if (baselineGap) {
						baselineGap.style.display = 'none';
					}
					return;
				}
				const activeRect = activeTab.getBoundingClientRect();
				const wrapRect = tabsWrap.getBoundingClientRect();
				const left = activeRect.left - wrapRect.left - 1;
				const width = activeRect.width + 2;
				baselineGap.style.left = left + 'px';
				baselineGap.style.width = width + 'px';
				baselineGap.style.display = 'block';
			}
			function updateTabsOverflowMode() {
				if (!tabsRow || !tabsMain || !tabsTrack) {
					updateTabBaselineGap();
					return;
				}
				tabsRow.classList.remove('tabs-overflowing');
				tabsMain.scrollLeft = 0;
				const requiresOverflow = tabsRow.scrollWidth > tabsRow.clientWidth + 1;
				if (requiresOverflow) {
					tabsRow.classList.add('tabs-overflowing');
					const maxScrollLeft = Math.max(0, tabsTrack.scrollWidth - tabsMain.clientWidth);
					tabsScrollLeft = Math.max(0, Math.min(tabsScrollLeft, maxScrollLeft));
					tabsMain.scrollLeft = tabsScrollLeft;
				} else {
					tabsScrollLeft = 0;
				}
				updateTabBaselineGap();
			}
			if (tabsMain) {
				tabsMain.addEventListener('scroll', () => {
					tabsScrollLeft = tabsMain.scrollLeft;
					suppressRenderUntil = Date.now() + 250;
					updateTabBaselineGap();
				}, { passive: true });
			}
			const refreshTabsOverlayScrollbar = setupOverlayScrollbar(
				tabsMain,
				tabsOverlayTrack,
				tabsOverlayThumb,
				'horizontal'
			);
			const refreshDetailOverlayScrollbar = setupOverlayScrollbar(
				detailArea,
				detailOverlayTrack,
				detailOverlayThumb,
				'vertical'
			);
			updateTabsOverflowMode();
			refreshTabsOverlayScrollbar();
			refreshDetailOverlayScrollbar();
			if (!resizeListenerAttached) {
				window.addEventListener('resize', () => {
					render();
				});
				resizeListenerAttached = true;
			}

			for (const configEnterButton of root.querySelectorAll('[data-config-enter-brick-id]')) {
				configEnterButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					const brickId = configEnterButton.dataset.configEnterBrickId || '';
					if (!brickId) {
						return;
					}
					const state = getTabConfigState(brickId);
					state.mode = true;
					state.menuOpen = false;
					state.actionInFlight = '';
					state.error = '';
					state.draftBrickName = getCurrentBrickDisplayName(brickId);
					closeAllConfigMenus(brickId);
					render();
				});
			}
			for (const configApplyButton of root.querySelectorAll('[data-config-apply-brick-id]')) {
				configApplyButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					const brickId = configApplyButton.dataset.configApplyBrickId || '';
					if (!brickId) {
						return;
					}
					const state = getTabConfigState(brickId);
					if (state.actionInFlight) {
						return;
					}
					state.menuOpen = false;
					state.actionInFlight = 'apply';
					state.error = '';
					discardRequestKindByBrickId.delete(brickId);
					render();
					const configuredName = (typeof state.draftBrickName === 'string' && state.draftBrickName.trim().length > 0)
						? state.draftBrickName
						: getCurrentBrickDisplayName(brickId);
					vscode.postMessage({ type: 'applyConfigChanges', brickId, brickName: configuredName });
				});
			}
			for (const configMenuToggleButton of root.querySelectorAll('[data-config-menu-toggle-brick-id]')) {
				configMenuToggleButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					const brickId = configMenuToggleButton.dataset.configMenuToggleBrickId || '';
					if (!brickId) {
						return;
					}
					const state = getTabConfigState(brickId);
					if (state.actionInFlight) {
						return;
					}
					const nextMenuOpen = !state.menuOpen;
					closeAllConfigMenus(brickId);
					state.menuOpen = nextMenuOpen;
					render();
				});
			}
			for (const configReloadButton of root.querySelectorAll('[data-config-reload-brick-id]')) {
				configReloadButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					const brickId = configReloadButton.dataset.configReloadBrickId || '';
					if (!brickId) {
						return;
					}
					const state = getTabConfigState(brickId);
					if (state.actionInFlight) {
						return;
					}
					state.menuOpen = false;
					state.actionInFlight = 'reload';
					state.error = '';
					discardRequestKindByBrickId.set(brickId, 'reload');
					render();
					vscode.postMessage({ type: 'discardConfigChanges', brickId });
				});
			}
			for (const configCancelButton of root.querySelectorAll('[data-config-cancel-brick-id]')) {
				configCancelButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					const brickId = configCancelButton.dataset.configCancelBrickId || '';
					if (!brickId) {
						return;
					}
					const state = getTabConfigState(brickId);
					if (state.actionInFlight) {
						return;
					}
					state.menuOpen = false;
					state.actionInFlight = 'cancel';
					state.error = '';
					discardRequestKindByBrickId.set(brickId, 'cancel');
					render();
					vscode.postMessage({ type: 'discardConfigChanges', brickId });
				});
			}
			for (const configNameInput of root.querySelectorAll('[data-config-name-input-brick-id]')) {
				configNameInput.addEventListener('input', () => {
					const brickId = configNameInput.dataset.configNameInputBrickId || '';
					if (!brickId) {
						return;
					}
					const state = getTabConfigState(brickId);
					state.draftBrickName = typeof configNameInput.value === 'string' ? configNameInput.value : '';
				});
			}
			for (const closeConfigMenuArea of root.querySelectorAll('.brick-detail-area, .brick-tabs-main')) {
				closeConfigMenuArea.addEventListener('click', () => {
					if (!closeAllConfigMenus()) {
						return;
					}
					render();
				});
			}

			for (const tab of root.querySelectorAll('.brick-tab')) {
				tab.addEventListener('click', () => {
					closeAllConfigMenus();
					if (tab.dataset.addBrick === 'true') {
						selectedDiscoveryCandidateId = '';
						requestDiscoveryScan({ preserveCandidates: true });
						return;
					}
					const nextBrickId = tab.dataset.brickId || '';
					if (!nextBrickId) {
						return;
					}
					bricks = bricks.map((brick) => ({
						...brick,
						isActive: brick.brickId === nextBrickId
					}));
					discoveryOpen = false;
					stopScanLoop();
					render();
					vscode.postMessage({ type: 'selectBrick', brickId: nextBrickId });
				});
			}
			for (const closeButton of root.querySelectorAll('.brick-tab-close')) {
				closeButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					closeAllConfigMenus();
					const brickId = closeButton.dataset.closeBrickId || '';
					if (!brickId) {
						return;
					}
					removeBrickImmediately(brickId);
					setCandidateConnectionState(brickId, 'UNKNOWN', false);
					render();
					vscode.postMessage({ type: 'disconnectBrick', brickId });
				});
			}
			for (const candidateButton of root.querySelectorAll('.discovery-item')) {
				candidateButton.addEventListener('click', () => {
					closeAllConfigMenus();
					const candidateId = candidateButton.dataset.candidateId || '';
					if (!candidateId) {
						return;
					}
					if (candidateButton.disabled || connectingDiscoveryCandidateId) {
						return;
					}
					selectedDiscoveryCandidateId = candidateId;
					const candidate = discoveryCandidates.find((item) => item.candidateId === candidateId);
					if (isCandidateReadyConnected(candidate)) {
						ensureBrickVisibleFromCandidate(candidateId, 'READY');
						discoveryOpen = false;
						stopScanLoop();
						render();
						vscode.postMessage({ type: 'selectBrick', brickId: candidateId });
						return;
					}
					connectingDiscoveryCandidateId = candidateId;
					setCandidateConnectionState(candidateId, 'CONNECTING', true);
					ensureBrickVisibleFromCandidate(candidateId, 'CONNECTING');
					render();
					vscode.postMessage({ type: 'connectScannedBrick', candidateId });
				});
			}
			for (const candidateActionButton of root.querySelectorAll('[data-candidate-action-id]')) {
				candidateActionButton.addEventListener('click', (event) => {
					event.preventDefault();
					event.stopPropagation();
					closeAllConfigMenus();
					const candidateId = candidateActionButton.dataset.candidateActionId || '';
					if (!candidateId || connectingDiscoveryCandidateId) {
						return;
					}
					const candidate = discoveryCandidates.find((item) => item.candidateId === candidateId);
					const toggle = resolveMockDiscoveryToggle(candidate);
					if (!toggle) {
						return;
					}
					selectedDiscoveryCandidateId = '';
					connectingDiscoveryCandidateId = candidateId;
					render();
					if (toggle.mode === 'disconnect') {
						vscode.postMessage({ type: 'setMockConnection', candidateId, connected: false });
						return;
					}
					if (toggle.mode === 'connect') {
						vscode.postMessage({ type: 'setMockConnection', candidateId, connected: true });
					}
				});
			}
		}

		window.addEventListener('message', (event) => {
			const message = event.data;
			if (message.type === 'updateBricks') {
				const nextBricks = stabilizeBrickOrder(message.bricks || []);
				const nextSensors = message.sensors || [];
				const nextMotors = message.motors || [];
				const nextControls = message.controls || null;
				const bricksChanged = !isSameSnapshot(nextBricks, bricks);
				const sensorsChanged = !isSameSnapshot(nextSensors, sensors);
				const motorsChanged = !isSameSnapshot(nextMotors, motors);
				const controlsChanged = !isSameSnapshot(nextControls, controls);
				if (bricksChanged) {
					bricks = nextBricks;
					pruneConfigStates();
				}
				if (sensorsChanged) {
					sensors = nextSensors;
				}
				if (motorsChanged) {
					motors = nextMotors;
				}
				if (controlsChanged) {
					controls = nextControls;
				}
				const discoveryChanged = syncDiscoveryCandidatesWithBricks();
				if (connectingDiscoveryCandidateId && connectingDiscoveryCandidateId.toLowerCase().startsWith('mock-')) {
					const status = resolveBrickStatus(connectingDiscoveryCandidateId);
					if (status !== 'CONNECTING') {
						connectingDiscoveryCandidateId = '';
					}
				}
				if (initialAutoScanPending && bricks.length === 0) {
					initialAutoScanPending = false;
					requestDiscoveryScan({ preserveCandidates: false });
					return;
				}
				initialAutoScanPending = false;
				const hasVisibleChanges = discoveryOpen
					? (bricksChanged || discoveryChanged)
					: (bricksChanged || sensorsChanged || motorsChanged || controlsChanged || discoveryChanged);
				if (hasVisibleChanges && Date.now() >= suppressRenderUntil) {
					render();
				}
				scheduleNextScan();
				return;
			}
			if (message.type === 'scanStarted') {
				let changed = false;
				if (!lastScanBackground) {
					const nextLoading = discoveryCandidates.length === 0;
					if (discoveryLoading !== nextLoading) {
						discoveryLoading = nextLoading;
						changed = true;
					}
					if (discoveryError) {
						discoveryError = '';
						changed = true;
					}
				}
				scanInFlight = true;
				if (discoveryOpen && changed) {
					render();
				}
				return;
			}
			if (message.type === 'scanResults') {
				let changed = false;
				if (!lastScanBackground) {
					if (discoveryLoading) {
						discoveryLoading = false;
						changed = true;
					}
					if (discoveryError) {
						discoveryError = '';
						changed = true;
					}
				}
				scanInFlight = false;
				if (mergeDiscoveryCandidates(message.candidates || [])) {
					changed = true;
				}
				if (connectingDiscoveryCandidateId) {
					changed = true;
				}
				connectingDiscoveryCandidateId = '';
				if (discoveryOpen && changed) {
					render();
				}
				scheduleNextScan();
				return;
			}
			if (message.type === 'scanFailed') {
				let changed = false;
				if (!lastScanBackground) {
					if (discoveryLoading) {
						discoveryLoading = false;
						changed = true;
					}
					const nextError = message.message || 'Brick scan failed.';
					if (discoveryError !== nextError) {
						discoveryError = nextError;
						changed = true;
					}
				}
				scanInFlight = false;
				if (connectingDiscoveryCandidateId) {
					changed = true;
				}
				connectingDiscoveryCandidateId = '';
				if (discoveryOpen && changed) {
					render();
				}
				scheduleNextScan();
				return;
			}
			if (message.type === 'connectStarted') {
				discoveryOpen = true;
				connectingDiscoveryCandidateId = message.candidateId || '';
				if (connectingDiscoveryCandidateId) {
					setCandidateConnectionState(connectingDiscoveryCandidateId, 'CONNECTING', true);
					ensureBrickVisibleFromCandidate(connectingDiscoveryCandidateId, 'CONNECTING');
				}
				discoveryError = '';
				render();
				return;
			}
			if (message.type === 'connectSucceeded') {
				const connectedCandidateId = message.candidateId || connectingDiscoveryCandidateId;
				if (connectedCandidateId) {
					setCandidateConnectionState(connectedCandidateId, 'READY', true);
					ensureBrickVisibleFromCandidate(connectedCandidateId, 'READY');
				}
				const keepDiscoveryOpen = connectedCandidateId
					&& keepDiscoveryOpenOnConnectCandidateId === connectedCandidateId;
				discoveryOpen = !!keepDiscoveryOpen;
				discoveryLoading = false;
				discoveryError = '';
				selectedDiscoveryCandidateId = keepDiscoveryOpen && connectedCandidateId
					? connectedCandidateId
					: '';
				connectingDiscoveryCandidateId = '';
				keepDiscoveryOpenOnConnectCandidateId = '';
				scanInFlight = false;
				if (!keepDiscoveryOpen) {
					stopScanLoop();
				}
				render();
				scheduleNextScan(!keepDiscoveryOpen);
				return;
			}
			if (message.type === 'connectFailed') {
				const failedCandidateId = message.candidateId || connectingDiscoveryCandidateId;
				if (failedCandidateId) {
					setCandidateConnectionState(failedCandidateId, 'UNKNOWN', false);
					removeBrickImmediately(failedCandidateId);
				}
				connectingDiscoveryCandidateId = '';
				keepDiscoveryOpenOnConnectCandidateId = '';
				discoveryError = message.message || 'Connect failed.';
				scanInFlight = false;
				render();
				scheduleNextScan();
				return;
			}
			if (message.type === 'configApplied') {
				const brickId = message.brickId || '';
				const normalizedBrickName = typeof message.brickName === 'string' ? message.brickName.trim() : '';
				const relatedBrickIds = Array.isArray(message.relatedBrickIds)
					? message.relatedBrickIds
						.filter((value) => typeof value === 'string')
						.map((value) => value.trim())
						.filter((value) => value.length > 0)
					: [];
				const targetBrickIds = new Set([brickId, ...relatedBrickIds]);
				if (normalizedBrickName.length > 0) {
					bricks = bricks.map((brick) =>
						targetBrickIds.has(brick.brickId)
							? { ...brick, displayName: normalizedBrickName }
							: brick
					);
					discoveryCandidates = discoveryCandidates.map((candidate) =>
						targetBrickIds.has(candidate.candidateId)
							? { ...candidate, displayName: normalizedBrickName }
							: candidate
					);
				}
				const state = getTabConfigState(brickId);
				state.actionInFlight = '';
				state.menuOpen = false;
				state.mode = false;
				state.error = '';
				state.draftBrickName = normalizedBrickName || getCurrentBrickDisplayName(brickId);
				discardRequestKindByBrickId.delete(brickId);
				render();
				return;
			}
			if (message.type === 'configDiscarded') {
				const brickId = message.brickId || '';
				const state = getTabConfigState(brickId);
				const discardKind = discardRequestKindByBrickId.get(brickId) || 'cancel';
				discardRequestKindByBrickId.delete(brickId);
				state.actionInFlight = '';
				state.menuOpen = false;
				state.error = '';
				state.mode = discardKind === 'reload';
				state.draftBrickName = getCurrentBrickDisplayName(brickId);
				render();
				return;
			}
			if (message.type === 'configActionFailed') {
				const brickId = message.brickId || '';
				const state = getTabConfigState(brickId);
				state.actionInFlight = '';
				state.menuOpen = false;
				state.error = message.message || 'Configuration action failed.';
				if (message.action === 'discard') {
					discardRequestKindByBrickId.delete(brickId);
				}
				render();
			}
		});

		vscode.postMessage({ type: 'ready' });
	</script>
</body>
</html>
